{"version":3,"sources":["bb_passrates/shared/main.cljc"],"mappings":";AAKA;;;;;;;mCAAA,nCAAMA,8EAMHC;AANH,AAOE,IAAMC,4GAAUD,1BACAE,vBACA,uBAAA,6BAAA,cAAA,lEAACC,nDACD,yHAAA,zHAACC;AAHjB,AAIE,OAACC,+CAAOC,uBAAOL;;AAEnB,4CAAA,5CAAMM,gGAAkBC,KAAKR;AAA7B,AACE,IAAMA,QAAE,AAACS,8CAAMC,cAAI,kDAAA,lDAACC,sDAAc,AAACZ,iCAAQC;AAA3C,AACE,sDAAA,WAAAY,1DAACC;AAAD,AAAS,OAACC,+BAAkB,AAAA,kGAAAF,kBAAkBZ;GAAGQ;;AAGrD,gCAAA,hCAAKO;AAEL,+BAAA,2CAAA,WAAA,YAAA,eAAA,aAAA,OAAA,pIAAKC;AAKL,AAAKC,6CACH,AAACC,uBAAWF;AAEd;;;sCAAA,mDAAAG,zFAAMI,oFAEHC;AAFH,AAAA,IAAAJ,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;WAAA,AAAAE,4CAAAF,eAAA,lEAEgBK;UAFhB,AAAAH,4CAAAF,eAAA,jEAEyBM;AAFzB,AAGE,IAAMC,KAKQ,4CAAA,WAAAE,vDAACC;AAAD,AAAM,yDAAA,IAAAD,tDAACE;0JALN,wBAAA,AAAA,mFAAA,oBAAA,7GAAMN,gGACGA,mBACV,uBAAA,AAAA,mFAAA,kBAAA,1GAAMC,8FACGA,5YACT,oEAAA,pEAACrB,+CAAOuB;AAJtB,AAME,GACE,oDAAA,pDAACI,yDAAMN,sDAAID;AAAMD;;AADnB,GAEE,uBAAA,tBAAG,AAACS,gBAAMN;AAAO,OAAClB,8CAAMC,cAAI,AAACwB,6CAAK,kDAAA,lDAACvB,sDAAcgB,IAAI,KAAAQ,eAAA,KAAA,IAAA,KAAAA,eAAA,UAAA,KAAA,IAAA,OAAA,IAAA,zBAAUX;;AAFjE,AAGQ,OAACf,8CAAMC,cAAI,AAACwB,6CAAKP,GAAG,KAAAQ,eAAA,KAAA,IAAA,KAAAA,eAAA,UAAA,KAAA,IAAA,OAAA,IAAA,zBAAUX;;;;;AAG1C,gDAAA,hDAAMY,wGAAmBC;AAAzB,AACE,GAAM,GAAK,AAAC/B,uBAAO+B;AAAnB,AAIS,OAACG,+CAAO,eAAAC,JAAKG;AAAL,AAAA,IAAAF,aAAAD;QAAA,AAAAE,4CAAAD,WAAA,IAAA,/DAAUG;QAAV,AAAAF,4CAAAD,WAAA,IAAA,/DAAYI;AAAZ,AACE,OAACC,8CAAMH,IAAI,gDAAA,hDAACI,sDAAcH,GAAGC;sCAFvC,4CAAA,WAAAP,vDAACT,nCACD;AADA,AAAM,0DAAAS,iBAAA,pEAACnC;GADP,+CAAA,WAAAkC,1DAACzB;AAAD,AAAS,sCAAAyB,iBAAA,hDAACxB;GADV,gEAAA,hEAACV,mDAAciC;;AADxB;;;AAOF;;;2CAAA,3CAAMY,8FAEHC,IAAIC,WAAWd;AAFlB,AAGE,IAAMa,UAAI,mEAAIA,nDAAI,uDAAA,vDAAC9C,hBAAqBgD;IAClCD,iBAAW,AAACH,gDAAQ,AAAC9C,0BAAmBiD;AAD9C,AAEE,8GAAA,2CAAA,2DAAA,7MAACE,qMAAYH,iFAAoBC,uBAC1B,AAACf,8CAAkBC","names":["bb-passrates.shared.main/clean-q","q","words","clojure.string/lower-case","clojure.string/replace","clojure.string.split","cljs.core.remove","cljs.core/empty?","bb-passrates.shared.main/query-place-list","list","cljs.core.apply","cljs.core/str","cljs.core.interpose","p1__11432#","cljs.core.filter","clojure.string/includes?","bb-passrates.shared.main/lang","bb-passrates.shared.main/seo","bb-passrates.shared.main/url->canonical","clojure.set/map-invert","p__11456","map__11457","cljs.core/--destructure-map","cljs.core.get","bb-passrates.shared.main/build-href","path","lang","foo","qs","cljs.core/nil?","p1__11449#","cljs.core.map","clojure.string.join","cljs.core._EQ_","cljs.core/count","cljs.core.into","cljs.core/List","bb-passrates.shared.main/query-string->map","query-string","p1__11493#","p1__11494#","cljs.core.reduce","p__11499","vec__11500","cljs.core.nth","acc","k","v","cljs.core.assoc","cljs.core.keyword","bb-passrates.shared.main/url->req-map","uri","req-method","cljs.core/first","cljs.core.merge"],"sourcesContent":["(ns bb-passrates.shared.main\n  (:require [clojure.string :as clj-str]\n            [clojure.set :refer [map-invert]]\n            [clojure.edn :as edn]))\n\n(defn clean-q\n  \"Allow:\n  - alphanumeric\n  - spaces\n  - comma: ','\n  \"\n  [q]\n  (let [words (-> q\n                  clj-str/lower-case\n                  (clj-str/replace #\"[^0-9a-z_ ]\" \"\")\n                  (clj-str/split #\" \"))]\n    (remove empty? words)))\n\n(defn query-place-list [list q]\n  (let [q (apply str (interpose \" \" (clean-q q)))]\n    (filter #(clj-str/includes? (:search-field %) q) list)))\n\n\n(def lang :pt)\n\n(def seo\n  {\"district\" \"distritos\"\n   \"municipality\" \"municipios\"\n   \"city\" \"cidades\"})\n\n(def url->canonical\n  (map-invert seo))\n\n(defn build-href\n  \"builds href taking into account a variable number of query strings\"\n  [path {:keys [url/lang url/foo]}]\n  (let [qs (->> [(when lang\n                  [\"lang\" lang])\n                (when foo\n                  [\"foo\" foo])]\n                (remove nil?)\n                (map #(clj-str/join \"=\" %)))]\n    (cond\n      (= nil foo lang) path\n      (> (count qs) 1) (apply str (into (interpose \"&\" qs) (list \"?\" path)))\n      :else (apply str (into qs (list \"?\" path))))))\n\n\n(defn query-string->map [query-string]\n  (when (not (empty? query-string))\n      (->> (clj-str/split query-string #\"&\")\n           (filter #(clj-str/includes? % \"=\"))\n           (map #(clj-str/split % #\"=\"))\n           (reduce (fn [acc [k v]]\n                     (assoc acc (keyword \"url\" k) v)) {}))))\n\n(defn url->req-map\n  \"parses query params and build a request map\"\n  [uri req-method query-string]\n  (let [uri (-> uri (clj-str/split #\"\\?\") first)\n        req-method (keyword (clj-str/lower-case req-method))]\n    (merge {:uri uri :request-method req-method}\n           (query-string->map query-string))))\n"]}